#!/usr/bin/env python3

import os
import sys
import numpy as np
import argparse

from triNNity.frontend import CompilerError, print_stderr

backends = ['optimizer-info', 'trinnity', 'armcl', 'mkldnn', 'tensorflow']

def fatal_error(msg):
  print_stderr(msg)
  exit(-1)

def validate_arguments(args):
  if (not args.backend in backends):
    fatal_error('Unknown backend selected (valid choices are: ' + ', '.join(backends) + ')')
  if (args.model is None) and (args.code_output is not None) :
    fatal_error('Model code generation requested but no input model description provided.')
  if (args.weights is None) and (args.data_output is not None) :
    fatal_error('Weight conversion requested but no input weight data provided.')
  if (args.code_output is None) and \
     (args.data_output is None) and \
     (args.topology_output is None) and \
     (args.layers_output is None) and \
     (args.graph_output is None) and \
     (args.constraints_output is None):
    fatal_error('No output paths specified.')

def convert_tensorflow(def_path, caffemodel_path, data_output_path, code_output_path, phase, verbose):
  try:
    from triNNity.backend.tensorflow import TensorFlowTransformer
    transformer = TensorFlowTransformer(def_path, caffemodel_path, verbose=verbose, phase=phase)
    print_stderr('Compiling for backend: tensorflow')

    if caffemodel_path is not None:
      print_stderr('Converting weights...')
      data = transformer.transform_data()
      with open(data_output_path, 'wb') as data_out:
        np.save(data_out, data)

    if code_output_path:
      print_stderr('Generating code for model...')
      with open(code_output_path, 'w') as src_out:
        src_out.write(transformer.transform_source()[0])
    print_stderr('Done.')
  except CompilerError as err:
    fatal_error('Error encountered: {}'.format(err))

def convert_trinnity(def_path, caffemodel_path, data_output_path, code_output_path, phase, verbose):
  preamble = '''#include <chrono>
#include <iostream>
#include <algorithm>
#include <triNNity/layer.h>
#include <triNNity/generic/layer.h>
#include <triNNity/dense/cpu/layer.h>

#ifndef GEMM_TYPE
#define GEMM_TYPE triNNity::GEMM_BLAS
#endif

#ifndef GEMV_TYPE
#define GEMV_TYPE triNNity::GEMV_BLAS
#endif

'''

  main_code_preamble_A = '''  unsigned times[NO_OF_RUNS];

  auto t1 = std::chrono::high_resolution_clock::now();

  for (unsigned i = 0; i < NO_OF_RUNS; i++) {
'''

  main_code_preamble_B = '''
    auto t2 = std::chrono::high_resolution_clock::now();
    times[i] = std::chrono::duration_cast<std::chrono::nanoseconds>(t2-t1).count();
    t1 = t2;
  }

  for (unsigned i = 0; i < NO_OF_RUNS; i++) {
    std::cout << times[i] << std::endl;
  }
  '''

  main_code_postamble = '''
  return 0;
}
  '''

  try:
    from triNNity.backend.triNNity import TrinnityTransformer
    transformer = TrinnityTransformer(def_path, caffemodel_path, verbose=verbose, phase=phase)
    print_stderr('Compiling for backend: triNNity')

    if caffemodel_path is not None:
      print_stderr('Converting weights...')
      data = transformer.transform_data()
      for (name, blobs) in data.items():
        for (bname, bdata) in blobs.items():
          shape = '_'.join([str(x) for x in bdata.shape])
          with open(os.path.join(data_output_path, name + '.' + bname + '.' + shape + '.bin'), 'wb') as data_out:
            data_out.write(bdata.tobytes('C'))

    if code_output_path:
      print_stderr('Generating code for model...')
      with open(code_output_path, 'w') as src_out:
        tsrc = transformer.transform_source()
        src_out.write(preamble)
        src_out.write('\n')
        src_out.write(tsrc[0])
        src_out.write('\n')
        src_out.write('int main(int argc, char **argv) {\n')
        src_out.write('\n')
        src_out.write(tsrc[1])
        src_out.write('  data = new ACTIVATION_TYPE[{}]();'.format(transformer.data_size))
        src_out.write('\n  ')
        src_out.write('\n  '.join(map(str, (list(map(lambda x: '{} = new {}[{}]();'.format(x[0], x[2], x[3]), transformer.declarations))))))
        src_out.write('\n')
        src_out.write('\n')
        src_out.write(tsrc[2])
        src_out.write(main_code_preamble_A)
        src_out.write(tsrc[3])
        src_out.write(main_code_preamble_B)
        src_out.write('\n')
        src_out.write('  std::cerr << "Classification:" << std::endl;')
        src_out.write('  std::for_each(' + str(transformer.output_node_name) + '->output, ' + str(transformer.output_node_name) + '->output+' + str(transformer.labels) + ', [](auto &x){ std::cerr << x << std::endl; });')
        src_out.write('  delete [] data;')
        src_out.write(main_code_postamble)
    print_stderr('Done.')
  except CompilerError as err:
    fatal_error('Error encountered: {}'.format(err))

def convert_armcl(def_path, caffemodel_path, data_output_path, code_output_path, phase, verbose):
  preamble = '''#include <chrono>
#include <iostream>
#include <algorithm>
#include <triNNity/layer.h>
#include <triNNity/generic/layer.h>
#include <triNNity/wrappers/armcl/layer.h>

#ifndef GEMM_TYPE
#define GEMM_TYPE triNNity::GEMM_BLAS
#endif

#ifndef GEMV_TYPE
#define GEMV_TYPE triNNity::GEMV_BLAS
#endif

'''

  main_code_preamble_A = '''  unsigned times[NO_OF_RUNS];

  auto t1 = std::chrono::high_resolution_clock::now();

  for (unsigned i = 0; i < NO_OF_RUNS; i++) {
'''

  main_code_preamble_B = '''
    auto t2 = std::chrono::high_resolution_clock::now();
    times[i] = std::chrono::duration_cast<std::chrono::nanoseconds>(t2-t1).count();
    t1 = t2;
  }

  for (unsigned i = 0; i < NO_OF_RUNS; i++) {
    std::cout << times[i] << std::endl;
  }
  '''

  main_code_postamble = '''
  return 0;
}
  '''

  try:
    from triNNity.backend.triNNity import TrinnityTransformer
    transformer = TrinnityTransformer(def_path, caffemodel_path, verbose=verbose, phase=phase)
    print_stderr('Compiling for backend: triNNity')

    if caffemodel_path is not None:
      print_stderr('Converting weights...')
      data = transformer.transform_data()
      for (name, blobs) in data.items():
        for (bname, bdata) in blobs.items():
          shape = '_'.join([str(x) for x in bdata.shape])
          with open(os.path.join(data_output_path, name + '.' + bname + '.' + shape + '.bin'), 'wb') as data_out:
            data_out.write(bdata.tobytes('C'))

    if code_output_path:
      print_stderr('Generating code for model...')
      with open(code_output_path, 'w') as src_out:
        tsrc = transformer.transform_source()
        src_out.write(preamble)
        src_out.write('\n')
        src_out.write(tsrc[0])
        src_out.write('\n')
        src_out.write('int main(int argc, char **argv) {\n')
        src_out.write('\n\n')
        src_out.write('arm_compute::CLScheduler::get().default_init();\n\n')
        src_out.write(tsrc[1])
        src_out.write('  data = new ACTIVATION_TYPE[{}]();'.format(transformer.data_size))
        src_out.write('\n  ')
        src_out.write('\n  '.join(map(str, (list(map(lambda x: '{} = new {}[{}]();'.format(x[0], x[2], x[3]), transformer.declarations))))))
        src_out.write('\n')
        src_out.write('\n')
        src_out.write(tsrc[2])
        src_out.write(main_code_preamble_A)
        src_out.write(tsrc[3])
        src_out.write(main_code_preamble_B)
        src_out.write('\n')
        src_out.write('  std::cerr << "Classification:" << std::endl;')
        src_out.write('  std::for_each(' + str(transformer.output_node_name) + '->output, ' + str(transformer.output_node_name) + '->output+' + str(transformer.labels) + ', [](auto &x){ std::cerr << x << std::endl; });')
        src_out.write('  delete [] data;')
        src_out.write(main_code_postamble)
    print_stderr('Done.')
  except CompilerError as err:
    fatal_error('Error encountered: {}'.format(err))


def convert_mkldnn(def_path, caffemodel_path, data_output_path, code_output_path, phase, verbose):
  preamble = '''#include <chrono>
#include <iostream>
#include <algorithm>
#include <triNNity/layer.h>
#include <triNNity/generic/layer.h>
#include <triNNity/wrappers/mkldnn/layer.h>

#ifndef GEMM_TYPE
#define GEMM_TYPE triNNity::GEMM_BLAS
#endif

#ifndef GEMV_TYPE
#define GEMV_TYPE triNNity::GEMV_BLAS
#endif

'''

  main_code_preamble_A = '''  unsigned times[NO_OF_RUNS];

  auto t1 = std::chrono::high_resolution_clock::now();

  for (unsigned i = 0; i < NO_OF_RUNS; i++) {
'''

  main_code_preamble_B = '''
    auto t2 = std::chrono::high_resolution_clock::now();
    times[i] = std::chrono::duration_cast<std::chrono::nanoseconds>(t2-t1).count();
    t1 = t2;
  }

  for (unsigned i = 0; i < NO_OF_RUNS; i++) {
    std::cout << times[i] << std::endl;
  }
  '''

  main_code_postamble = '''
  return 0;
}
  '''

  try:
    from triNNity.backend.triNNity import TrinnityTransformer
    transformer = TrinnityTransformer(def_path, caffemodel_path, verbose=verbose, phase=phase)
    print_stderr('Compiling for backend: triNNity')

    if caffemodel_path is not None:
      print_stderr('Converting weights...')
      data = transformer.transform_data()
      for (name, blobs) in data.items():
        for (bname, bdata) in blobs.items():
          shape = '_'.join([str(x) for x in bdata.shape])
          with open(os.path.join(data_output_path, name + '.' + bname + '.' + shape + '.bin'), 'wb') as data_out:
            data_out.write(bdata.tobytes('C'))

    if code_output_path:
      print_stderr('Generating code for model...')
      with open(code_output_path, 'w') as src_out:
        tsrc = transformer.transform_source()
        src_out.write(preamble)
        src_out.write('\n')
        src_out.write(tsrc[0])
        src_out.write('\n')
        src_out.write('int main(int argc, char **argv) {\n')
        src_out.write('\n')
        src_out.write(tsrc[1])
        src_out.write('  data = new ACTIVATION_TYPE[{}]();'.format(transformer.data_size))
        src_out.write('\n  ')
        src_out.write('\n  '.join(map(str, (list(map(lambda x: '{} = new {}[{}]();'.format(x[0], x[2], x[3]), transformer.declarations))))))
        src_out.write('\n')
        src_out.write('\n')
        src_out.write(tsrc[2])
        src_out.write(main_code_preamble_A)
        src_out.write(tsrc[3])
        src_out.write(main_code_preamble_B)
        src_out.write('\n')
        src_out.write('  std::cerr << "Classification:" << std::endl;')
        src_out.write('  std::for_each(' + str(transformer.output_node_name) + '->output, ' + str(transformer.output_node_name) + '->output+' + str(transformer.labels) + ', [](auto &x){ std::cerr << x << std::endl; });')
        src_out.write('  delete [] data;')
        src_out.write(main_code_postamble)
    print_stderr('Done.')
  except CompilerError as err:
    fatal_error('Error encountered: {}'.format(err))

def convert_optimizer_info(def_path, caffemodel_path, topo_output_path, layer_output_path, constraints_output_path, graph_output_path, phase, verbose):
  try:
    from triNNity.backend.optimizer_info import InfoTransformer
    transformer = InfoTransformer(def_path, caffemodel_path, verbose=verbose, phase=phase)
    print_stderr('Compiling for backend: optimizer info')

    tsrc = transformer.transform_source()
    if topo_output_path:
      print_stderr('Generating topology for model...')
      with open(topo_output_path, 'w') as src_out:
        src_out.write(tsrc[0])

    if layer_output_path:
      print_stderr('Generating layer info for model...')
      with open(layer_output_path, 'w') as src_out:
        src_out.write(tsrc[1])

    if constraints_output_path:
      print_stderr('Generating layer constraint info for model...')
      with open(constraints_output_path, 'w') as src_out:
        src_out.write(tsrc[2])

    if graph_output_path:
      print_stderr('Generating visual graph description for model...')
      with open(graph_output_path, 'w') as src_out:
        nodes = tsrc[3]
        node_indices = range(0, len(nodes))
        edges = tsrc[4]
        src_out.write('graph ' + transformer.graph.name + '{\n')

        for (k, v) in zip(node_indices, nodes):
          src_out.write(str(k) + ' [label=' + v + '];\n')

        for (a, b) in edges:
          src_out.write(str(a) + ' -> ' + str(b) + ';\n')

        src_out.write('}')


    print_stderr('Done.')
  except CompilerError as err:
    fatal_error('Error encountered: {}'.format(err))

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--model', help='Input model definition (.prototxt) path')
    parser.add_argument('--weights', help='Input model data (.caffemodel) path')
    parser.add_argument('--data-output', help='Place converted weights in this directory')
    parser.add_argument('--code-output', help='Generate source code into this file')
    parser.add_argument('--topology-output', help='Generate topology description into this file')
    parser.add_argument('--layers-output', help='Generate layer description into this file')
    parser.add_argument('--constraints-output', help='Generate layer constraints into this file')
    parser.add_argument('--graph-output', help='Generate visual graph description into this file')
    parser.add_argument('--backend', default='trinnity', help='Which backend to use for code generation')
    parser.add_argument('-p',
                        '--phase',
                        default='test',
                        help='The phase to convert: test (default) or train')
    parser.add_argument('-v',
                        '--verbose',
                        help='Verbose compilation output')
    args = parser.parse_args()
    validate_arguments(args)
    if (args.backend == 'tensorflow'):
      convert_tensorflow(args.model, args.weights, args.data_output, args.code_output, args.phase, args.verbose)
    elif (args.backend == 'trinnity'):
      convert_trinnity(args.model, args.weights, args.data_output, args.code_output, args.phase, args.verbose)
    elif (args.backend == 'armcl'):
      convert_armcl(args.model, args.weights, args.data_output, args.code_output, args.phase, args.verbose)
    elif (args.backend == 'mkldnn'):
      convert_mkldnn(args.model, args.weights, args.data_output, args.code_output, args.phase, args.verbose)
    elif (args.backend == 'optimizer-info'):
      convert_optimizer_info(args.model, args.weights, args.topology_output, args.layers_output, args.constraints_output, args.graph_output, args.phase, args.verbose)
    else:
      fatal_error('No backend selected')

if __name__ == '__main__':
    main()
